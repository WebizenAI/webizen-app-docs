
# Guide: Using Hypermedia Content Packages

This guide provides a practical walkthrough for developers on how to create, sign, and share a **Hypermedia Content Package** using the Webizen API. These packages are the standard way to bundle and distribute rich, multi-format content within the ecosystem.

---

## Prerequisites

Before you start, you should be familiar with the core concepts of:

- [Data Storage in Webizen](../core-concepts/data-storage)
- [Hypermedia Content Packages](../core-concepts/hypermedia-packages)
- [Working with Data in Webizen](./working-with-data)

---

## The Goal

We will create a simple Hypermedia Package for a blog post. The package will contain:

1. The post content as an `index.html` file.
2. An associated image file.
3. An RDF manifest file describing the contents.
4. An ODRL policy file defining the content as free to read.

The entire package will then be signed and stored on IPFS.

---

## Step 1: Prepare the Assets

First, let's assume you have the following files ready in a local directory:

- `index.html`: The main content of the blog post.
- `image.png`: An image used in the post.
- `policy.odrl.ttl`: An ODRL file specifying the usage rights.
- `manifest.rdf.ttl`: The RDF manifest file.

**Example `manifest.rdf.ttl`:**

```turtle
@prefix dct: <http://purl.org/dc/terms/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix ex: <#> .

<> a foaf:Document ;
    dct:title "My First Hypermedia Post" ;
    dct:creator <https://user.pod.example/profile#me> ;
    dct:hasPart ex:content, ex:image, ex:policy .

ex:content a foaf:Document ;
    rdfs:label "Post Content" ;
    dct:format "text/html" ;
    dct:source "index.html" .

ex:image a foaf:Image ;
    rdfs:label "Post Image" ;
    dct:format "image/png" ;
    dct:source "image.png" .

ex:policy a <http://www.w3.org/ns/odrl/2/Policy> ;
    rdfs:label "Usage Policy" ;
    dct:format "text/turtle" ;
    dct:source "policy.odrl.ttl" .
```

---

## Step 2: Create the Package using the API

Within a Webizen module, you would gather these assets and use a high-level API function to create the package. This function would be part of a dedicated hypermedia service.

```javascript
// In a module's event handler

async function createAndSharePackage(files) {
  const { eventBus, hypermedia } = window.webizen;

  try {
    // 1. Create the package
    // The `createPackage` function takes an array of file objects
    // and returns a Blob of the compressed archive (e.g., a ZIP file).
    const packageBlob = await hypermedia.createPackage(files);

    // 2. Sign the package
    // The `sign` function from the crypto service will use SPHINCS+
    // for this data type.
    const signatureObject = await window.webizen.crypto.sign(packageBlob, {
      dataType: 'hypermediaPackage'
    });

    // 3. Upload the package and its signature to IPFS
    const packageCid = await window.webizen.ipfs.add(packageBlob);
    const signatureCid = await window.webizen.ipfs.add(JSON.stringify(signatureObject));

    // 4. Announce the new package to the network
    eventBus.emit('hypermedia:new_package', {
      packageCid: packageCid.toString(),
      signatureCid: signatureCid.toString()
    });
    
    console.log(`Package created and shared! CID: ${packageCid.toString()}`);
    
  } catch (error) {
    console.error("Failed to create package:", error);
  }
}
```

---

## Step 3: Receiving and Verifying a Package

Another user's client would listen for the `hypermedia:new_package` event. The handler would then download and verify the package.

```javascript
// In another client's module

eventBus.on('hypermedia:new_package', async (event) => {
  const { packageCid, signatureCid } = event.payload;

  try {
    // 1. Download the package and its signature from IPFS
    const packageBlob = await window.webizen.ipfs.get(packageCid);
    const signatureObject = JSON.parse(await window.webizen.ipfs.get(signatureCid));

    // 2. Verify the signature
    const isValid = await window.webizen.crypto.verify(
      signatureObject,
      packageBlob,
      signatureObject.signerWebId // The WebID of the creator
    );

    if (!isValid) {
      console.error("Package signature is invalid! Discarding.");
      return;
    }

    console.log("Package is authentic and verified.");

    // 3. Unpack and render the content
    // The `unpack` function would read the manifest and prepare the content for display.
    const content = await window.webizen.hypermedia.unpack(packageBlob);
    
    // Now the UI can render the `content` according to its manifest.
    
  } catch (error) {
    console.error("Failed to process package:", error);
  }
});
```

---

This workflow demonstrates the end-to-end process of creating, securing, sharing, and verifying a Hypermedia Content Package. It combines data bundling, post-quantum cryptography, and decentralized storage to create a powerful and trustworthy system for rich content distribution.