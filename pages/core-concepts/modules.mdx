# export const type = "page"
# export const title = "The Webizen Modular System"
# The Webizen Modular System

Webizen's functionality is not built as a single, monolithic application. Instead, it is a composite of independent, interoperable **modules**. This modular architecture is a core design principle that makes the platform flexible, extensible, and resilient.

## Philosophy

The modular approach is central to Webizen's goal of creating a decentralized and user-driven ecosystem.

- **Extensibility:** New features and capabilities can be added to the platform simply by creating a new module. This lowers the barrier for community contributions and allows for rapid innovation.
- **User Choice:** Users can choose which modules to enable, tailoring the platform to their specific needs and preferences. If a user disagrees with the functionality of a core module, they can disable it or even replace it with an alternative.
- **Isolation & Security:** Modules are self-contained units. While they can communicate with each other via a structured event bus, they do not have direct access to the internal state of other modules. This isolation enhances the security and stability of the overall platform.

## The Module Lifecycle

The entire lifecycle of modules within the Webizen Desktop Application is managed by the **Module Manager** (`services/moduleManager.js`).

1.  **Discovery:** On startup, the Module Manager scans the `src/modules/` directory to discover all available modules.
2.  **Configuration Loading:** It reads the `config/webizen-config-v0.26.json` file to determine which modules should be activated for the user.
3.  **Dynamic Loading:** The Module Manager dynamically loads the code for each activated module.
4.  **Initialization:** It calls the `init()` function on each module, passing in any necessary services (like access to the database or the event bus) through dependency injection. This is where a module sets up its initial state and registers its event listeners.
5.  **Event Handling:** Once initialized, modules operate primarily by reacting to events broadcast on the central **Event Bus** (`services/eventBus.js`). They can also dispatch their own events to be handled by other modules.

## The Standard Module Interface

To ensure interoperability, every Webizen module is expected to adhere to a standard interface. While not a strict requirement for all files, the main `index.js` of a module typically exposes the following functions:

- **`init(services)`**: This function is called once when the module is first loaded. It receives a `services` object containing references to core platform services (e.g., `quadstore`, `ipfs`, `eventBus`). The module should use this function to perform any necessary setup, such as initializing its internal state or registering listeners on the event bus.

- **`handleEvent(event)`**: This function is the module's primary entry point for reacting to system-wide events. The event bus will call this function with an `event` object (`{ type: 'string', payload: 'any' }`) when a relevant event occurs.

- **`getData(query)`**: Provides a standardized way for other parts of the system to request data from the module. The format of the `query` and the returned data is specific to each module's domain.

### Example Module Skeleton

Here is a simplified skeleton of a module's `index.js` file:

```javascript
// src/modules/example/index.js

let eventBus;
let internalState = { count: 0 };

export function init(services) {
  console.log('Example Module Initialized');
  eventBus = services.eventBus;

  // Listen for specific events
  eventBus.on('user:login', handleUserLogin);
}

export function handleEvent(event) {
  if (event.type === 'example:increment') {
    internalState.count += event.payload.amount || 1;
    eventBus.emit('example:updated', { newCount: internalState.count });
  }
}

export function getData(query) {
  if (query.type === 'get_count') {
    return internalState.count;
  }
  return null;
}

function handleUserLogin(event) {
  console.log(`User ${event.payload.userId} logged in. Resetting count.`);
  internalState.count = 0;
}