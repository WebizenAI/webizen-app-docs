

# Guide: Working with Data in Webizen

This guide explains how a Webizen module can create, read, update, and delete data. It builds upon the concepts introduced in the [Creating a Module](./creating-a-module) guide.



# Guide: Working with Data in Webizen

This guide explains how a Webizen module can create, read, update, and delete data. It builds upon the concepts introduced in the [Creating a Module](./creating-a-module) guide.

---

## Data Storage Architecture: A Quick Recap

Before we dive into the code, let's quickly recap Webizen's data storage layers:

1. **Quadstore (Local Cache):** A high-speed RDF database for immediate application use. All primary operations happen here for performance.
2. **Solid Pod (Authoritative Store):** The user's personal data server. The Quadstore is periodically synchronized with the Solid Pod, which acts as the source of truth.
3. **IPFS (File Storage):** A P2P network for storing binary files. The RDF graph in the Solid Pod stores links (CIDs) to files on IPFS.

As a module developer, you will primarily interact with the **Quadstore** for structured RDF data and the **IPFS service** for files. The background process handles the synchronization between the Quadstore and the Solid Pod automatically.

---

## The `services` Object

When your module's `init(services)` function is called, it receives a `services` object. This object is your gateway to the rest of the platform. The two most important services for data are:

- `services.quadstore`: The interface to the local RDF database.
- `services.ipfs`: The interface for interacting with the IPFS network.

---

## Example: Writing and Reading RDF Data

Let's extend our "Greeter" module to store its greeting message in the Quadstore instead of an in-memory variable.

### Step 1: Update the Module Logic

Modify your `src/modules/greeter/index.js` to use the `quadstore` service.

```javascript
// src/modules/greeter/index.js
import { DataFactory } from 'n3';

const { namedNode, literal } = DataFactory;

let eventBus;
let quadstore;

// Define a unique IRI for our greeting data
const GREETING_IRI = namedNode('http://webizen.org/data/greeter/greeting');
const GREETING_PREDICATE = namedNode('http://webizen.org/ontologies/greeter-v1#hasText');

export async function init(services) {
  console.log('Greeter Module Initialized');
  eventBus = services.eventBus;
  quadstore = services.quadstore;

  // Ensure a default greeting exists on first run
  const count = await quadstore.countQuads(GREETING_IRI, GREETING_PREDICATE, null, null);
  if (count === 0) {
    await quadstore.put(GREETING_IRI, GREETING_PREDICATE, literal("Hello from the Quadstore!"), null);
  }
}

export async function handleEvent(event) {
  if (event.type === 'greeter:change_greeting') {
    const { newGreeting } = event.payload;
    // First, remove the old greeting
    await quadstore.del(GREETING_IRI, GREETING_PREDICATE, null, null);
    // Then, add the new one
    await quadstore.put(GREETING_IRI, GREETING_PREDICATE, literal(newGreeting), null);
    // Emit an event to notify the system that our data has changed.
    eventBus.emit('greeter:updated', { greeting: newGreeting });
  }
}

export async function getData(query) {
  if (query.type === 'get_greeting') {
    const stream = await quadstore.get({ subject: GREETING_IRI, predicate: GREETING_PREDICATE });
    return new Promise((resolve, reject) => {
      stream.on('data', (quad) => resolve(quad.object.value));
      stream.on('end', () => resolve("Hello, World!")); // Default if not found
      stream.on('error', reject);
    });
  }
  return null;
}
```

**Key Changes:**

- We now import `n3` to create RDF terms.
- We define a unique `namedNode` (an IRI) to act as the subject for our greeting data.
- In `init()`, we check if a greeting already exists and create a default one if not.
- `handleEvent()` now performs `del` and `put` operations on the quadstore.
- `getData()` now asynchronously reads from the quadstore stream to find the greeting.

---

### Step 2: Update the UI Component

The UI component needs to be updated to handle the asynchronous nature of `getData`.

```javascript
// src/modules/greeter/component.js
import React, { useState, useEffect } from 'react';

const { eventBus, modules } = window.webizen;

export function GreeterComponent() {
  const [greeting, setGreeting] = useState('Loading...');

  useEffect(() => {
    const fetchGreeting = async () => {
      const initialGreeting = await modules.getData('greeter', { type: 'get_greeting' });
      setGreeting(initialGreeting);
    };
    fetchGreeting();

    const handleUpdate = (event) => {
      setGreeting(event.payload.greeting);
    };

    eventBus.on('greeter:updated', handleUpdate);

    return () => {
      eventBus.off('greeter:updated', handleUpdate);
    };
  }, []);

  // ... (the rest of the component remains the same)
}
```

Now, your module's state is persisted in the local RDF database and will be automatically synchronized with the user's Solid Pod, making it a permanent part of their data fabric.

---

## Example: Working with Files on IPFS

Let's add a feature to upload a profile picture.

1. **Get the file from the user:** Your UI component would have an `<input type="file" />` element. The `onChange` handler provides the file object.
2. **Call the IPFS service:** In your module logic, you would add a handler for an event like `greeter:upload_avatar`.

```javascript
// In src/modules/greeter/index.js

// ... inside handleEvent()
if (event.type === 'greeter:upload_avatar') {
    const file = event.payload.file;
    try {
        // The ipfs service handles the upload and returns the CID
        const cid = await services.ipfs.add(file.path); // Assuming file object has a path for Electron

        // Now, store the CID in the Quadstore, linking it to the user's profile
        const userWebId = namedNode('https://user.pod.example/profile#me'); // Get this dynamically
        const avatarPredicate = namedNode('http://xmlns.com/foaf/0.1/img');

        await quadstore.del(userWebId, avatarPredicate, null, null);
        await quadstore.put(userWebId, avatarPredicate, namedNode(`ipfs://${cid}`), null);

        eventBus.emit('greeter:avatar_updated', { cid: cid.toString() });
    } catch (error) {
        console.error("Failed to upload avatar", error);
    }
}
```

This example shows the complete data flow: the binary file goes to IPFS, and the resulting immutable link (CID) is stored as structured metadata in the user's data graph.

## Data Storage Architecture: A Quick Recap

Before we dive into the code, let's quickly recap Webizen's data storage layers:

1. **Quadstore (Local Cache):** A high-speed RDF database for immediate application use. All primary operations happen here for performance.
2. **Solid Pod (Authoritative Store):** The user's personal data server. The Quadstore is periodically synchronized with the Solid Pod, which acts as the source of truth.
3. **IPFS (File Storage):** A P2P network for storing binary files. The RDF graph in the Solid Pod stores links (CIDs) to files on IPFS.

As a module developer, you will primarily interact with the **Quadstore** for structured RDF data and the **IPFS service** for files. The background process handles the synchronization between the Quadstore and the Solid Pod automatically.

---

## The `services` Object

When your module's `init(services)` function is called, it receives a `services` object. This object is your gateway to the rest of the platform. The two most important services for data are:

- `services.quadstore`: The interface to the local RDF database.
- `services.ipfs`: The interface for interacting with the IPFS network.

---

## Example: Writing and Reading RDF Data

Let's extend our "Greeter" module to store its greeting message in the Quadstore instead of an in-memory variable.

### Step 1: Update the Module Logic

Modify your `src/modules/greeter/index.js` to use the `quadstore` service.

```javascript
// src/modules/greeter/index.js
import { DataFactory } from 'n3';

const { namedNode, literal } = DataFactory;

let eventBus;
let quadstore;

// Define a unique IRI for our greeting data
const GREETING_IRI = namedNode('http://webizen.org/data/greeter/greeting');
const GREETING_PREDICATE = namedNode('http://webizen.org/ontologies/greeter-v1#hasText');

export async function init(services) {
  console.log('Greeter Module Initialized');
  eventBus = services.eventBus;
  quadstore = services.quadstore;

  // Ensure a default greeting exists on first run
  const count = await quadstore.countQuads(GREETING_IRI, GREETING_PREDICATE, null, null);
  if (count === 0) {
    await quadstore.put(GREETING_IRI, GREETING_PREDICATE, literal("Hello from the Quadstore!"), null);
  }
}

export async function handleEvent(event) {
  if (event.type === 'greeter:change_greeting') {
    const { newGreeting } = event.payload;
    // First, remove the old greeting
    await quadstore.del(GREETING_IRI, GREETING_PREDICATE, null, null);
    // Then, add the new one
    await quadstore.put(GREETING_IRI, GREETING_PREDICATE, literal(newGreeting), null);
    // Emit an event to notify the system that our data has changed.
    eventBus.emit('greeter:updated', { greeting: newGreeting });
  }
}

export async function getData(query) {
  if (query.type === 'get_greeting') {
    const stream = await quadstore.get({ subject: GREETING_IRI, predicate: GREETING_PREDICATE });
    return new Promise((resolve, reject) => {
      stream.on('data', (quad) => resolve(quad.object.value));
      stream.on('end', () => resolve("Hello, World!")); // Default if not found
      stream.on('error', reject);
    });
  }
  return null;
}
```

**Key Changes:**

- We now import `n3` to create RDF terms.
- We define a unique `namedNode` (an IRI) to act as the subject for our greeting data.
- In `init()`, we check if a greeting already exists and create a default one if not.
- `handleEvent()` now performs `del` and `put` operations on the quadstore.
- `getData()` now asynchronously reads from the quadstore stream to find the greeting.

---

### Step 2: Update the UI Component

The UI component needs to be updated to handle the asynchronous nature of `getData`.

```javascript
// src/modules/greeter/component.js
import React, { useState, useEffect } from 'react';

const { eventBus, modules } = window.webizen;

export function GreeterComponent() {
  const [greeting, setGreeting] = useState('Loading...');

  useEffect(() => {
    const fetchGreeting = async () => {
      const initialGreeting = await modules.getData('greeter', { type: 'get_greeting' });
      setGreeting(initialGreeting);
    };
    fetchGreeting();

    const handleUpdate = (event) => {
      setGreeting(event.payload.greeting);
    };

    eventBus.on('greeter:updated', handleUpdate);

    return () => {
      eventBus.off('greeter:updated', handleUpdate);
    };
  }, []);

  // ... (the rest of the component remains the same)
}
```

Now, your module's state is persisted in the local RDF database and will be automatically synchronized with the user's Solid Pod, making it a permanent part of their data fabric.

---

## Example: Working with Files on IPFS

Let's add a feature to upload a profile picture.

1. **Get the file from the user:** Your UI component would have an `<input type="file" />` element. The `onChange` handler provides the file object.
2. **Call the IPFS service:** In your module logic, you would add a handler for an event like `greeter:upload_avatar`.

```javascript
// In src/modules/greeter/index.js

// ... inside handleEvent()
if (event.type === 'greeter:upload_avatar') {
    const file = event.payload.file;
    try {
        // The ipfs service handles the upload and returns the CID
        const cid = await services.ipfs.add(file.path); // Assuming file object has a path for Electron

        // Now, store the CID in the Quadstore, linking it to the user's profile
        const userWebId = namedNode('https://user.pod.example/profile#me'); // Get this dynamically
        const avatarPredicate = namedNode('http://xmlns.com/foaf/0.1/img');

        await quadstore.del(userWebId, avatarPredicate, null, null);
        await quadstore.put(userWebId, avatarPredicate, namedNode(`ipfs://${cid}`), null);

        eventBus.emit('greeter:avatar_updated', { cid: cid.toString() });
    } catch (error) {
        console.error("Failed to upload avatar", error);
    }
}
```

This example shows the complete data flow: the binary file goes to IPFS, and the resulting immutable link (CID) is stored as structured metadata in the user's data graph.
