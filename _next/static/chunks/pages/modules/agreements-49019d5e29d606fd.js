(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7621],{8702:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/modules/agreements",function(){return s(8174)}])},8174:function(e,n,s){"use strict";s.r(n),s.d(n,{__toc:function(){return a}});var t=s(2676),i=s(57),r=s(8949);let a=[{depth:2,value:"Purpose and Functionality",id:"purpose-and-functionality"},{depth:2,value:"Technical Implementation",id:"technical-implementation"},{depth:3,value:"Example Flow: Creating a Connection Request",id:"example-flow-creating-a-connection-request"}];function l(e){let n=Object.assign({h1:"h1",p:"p",strong:"strong",h2:"h2",code:"code",ul:"ul",li:"li",h3:"h3",ol:"ol"},(0,r.a)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{children:"Module: Agreements"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"The Agreements module provides the framework for creating, managing, and securely signing formal, RDF-based agreements between users. This module is essential for establishing high-trust interactions, such as connection requests, content licenses, and work contracts."})}),"\n",(0,t.jsx)(n.p,{children:"By representing agreements as structured, signed data, Webizen transforms them from static legal text into dynamic, machine-readable contracts that can be automatically validated and enforced."}),"\n",(0,t.jsx)(n.h2,{id:"purpose-and-functionality",children:"Purpose and Functionality"}),"\n",(0,t.jsxs)(n.p,{children:["The primary goal of the ",(0,t.jsx)(n.code,{children:"agreements"})," module is to formalize relationships and exchanges within the Webizen ecosystem in a secure, transparent, and verifiable manner."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Core Functions:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Agreement Creation:"}),' Provides UI and logic for users to draft agreements based on predefined templates (e.g., a standard "Contact Connection Request").']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RDF-based Structure:"})," All agreements are structured as RDF data, using ontologies like ODRL to define the terms, permissions, and duties of the parties involved."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"IPFS Storage:"})," The finalized RDF agreement is stored as an immutable file on IPFS, ensuring its content cannot be altered after creation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"SHACL Validation:"})," Before an agreement is finalized, its RDF structure is validated against a corresponding SHACL shape (e.g., ",(0,t.jsx)(n.code,{children:"agreements-v1.shacl.ttl"}),") to guarantee it is well-formed and complete."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Post-Quantum Signatures:"})," To ensure long-term, non-repudiable authenticity, all agreements are digitally signed using the ",(0,t.jsx)(n.strong,{children:"SPHINCS+"})," post-quantum signature algorithm."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"technical-implementation",children:"Technical Implementation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Module Path"}),": ",(0,t.jsx)(n.code,{children:"src/modules/agreements/index.js"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"UI Component"}),": The interface for creating and viewing agreements is rendered by ",(0,t.jsx)(n.code,{children:"src/components/Agreements.js"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Core Libraries"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"shacl-validator"}),": For validating the structure of the agreement's RDF data."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Ontologies"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ontologies/agreements-v1.shacl.ttl"}),": Defines the required shape for a valid agreement."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"ODRL"}),": The Open Digital Rights Language is often used within agreements to specify permissions and duties."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dependencies"}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"services/crypto"}),": Used to sign the final agreement hash with SPHINCS+."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"services/ipfs"}),": To store the agreement file and get its CID."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"services/solidos"}),": To store the record of the agreement (including the IPFS CID and signature) in the user's Solid Pod."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"modules/addressbook"}),": To link agreements to the specific contacts involved."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-flow-creating-a-connection-request",children:"Example Flow: Creating a Connection Request"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:'User Alice wants to formally connect with Bob. She navigates to Bob\'s profile in her address book and clicks "Create Agreement," selecting the "Contact Connection" template.'}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"Agreements.js"}),' component presents a pre-filled form based on the template. Alice adds a personal note and clicks "Propose."']}),"\n",(0,t.jsxs)(n.li,{children:["The UI dispatches an event to the ",(0,t.jsx)(n.code,{children:"agreements"})," module with the agreement data."]}),"\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"agreements"})," module constructs the final RDF data for the agreement."]}),"\n",(0,t.jsxs)(n.li,{children:["It validates this data against ",(0,t.jsx)(n.code,{children:"agreements-v1.shacl.ttl"}),". If valid, it proceeds."]}),"\n",(0,t.jsxs)(n.li,{children:["It saves the RDF data to a file and adds it to IPFS, receiving a ",(0,t.jsx)(n.code,{children:"cid"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["It then calls the ",(0,t.jsx)(n.code,{children:"crypto"})," service to sign the ",(0,t.jsx)(n.code,{children:"cid"})," using the ",(0,t.jsx)(n.code,{children:"'agreement'"})," policy, which resolves to ",(0,t.jsx)(n.strong,{children:"SPHINCS+"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The module creates a final RDF record containing the ",(0,t.jsx)(n.code,{children:"cid"})," and the ",(0,t.jsx)(n.code,{children:"signatureObject"}),", saves this record to Alice's Solid Pod, and sends a message to Bob with the record's location."]}),"\n",(0,t.jsx)(n.li,{children:"Bob's client can then fetch the agreement from IPFS, verify the SPHINCS+ signature against Alice's WebID, and choose to accept or reject the connection."}),"\n"]})]})}n.default=(0,i.j)({MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.a)(),e.components);return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)},pageOpts:{filePath:"pages/modules/agreements.mdx",route:"/modules/agreements",timestamp:1752449798e3,title:"Module: Agreements",headings:a},pageNextRoute:"/modules/agreements"})}},function(e){e.O(0,[57,2888,9774,179],function(){return e(e.s=8702)}),_N_E=e.O()}]);